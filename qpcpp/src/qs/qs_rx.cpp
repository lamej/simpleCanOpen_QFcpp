//$file${src::qs::qs_rx.cpp} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
//
// Model: qpcpp.qm
// File:  ${src::qs::qs_rx.cpp}
//
// This code has been generated by QM 5.3.0 <www.state-machine.com/qm>.
// DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
//
// This code is covered by the following QP license:
// License #    : LicenseRef-QL-dual
// Issued to    : Any user of the QP/C++ real-time embedded framework
// Framework(s) : qpcpp
// Support ends : 2024-12-31
// License scope:
//
// Copyright (C) 2005 Quantum Leaps, LLC <state-machine.com>.
//
//                    Q u a n t u m  L e a P s
//                    ------------------------
//                    Modern Embedded Software
//
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-QL-commercial
//
// This software is dual-licensed under the terms of the open source GNU
// General Public License version 3 (or any later version), or alternatively,
// under the terms of one of the closed source Quantum Leaps commercial
// licenses.
//
// The terms of the open source GNU General Public License version 3
// can be found at: <www.gnu.org/licenses/gpl-3.0>
//
// The terms of the closed source Quantum Leaps commercial licenses
// can be found at: <www.state-machine.com/licensing>
//
// Redistributions in source code must retain this top-level comment block.
// Plagiarizing this software to sidestep the license obligations is illegal.
//
// Contact information:
// <www.state-machine.com/licensing>
// <info@state-machine.com>
//
//$endhead${src::qs::qs_rx.cpp} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
#define QP_IMPL             // this is QP implementation
#include "qs_port.hpp"      // QS port
#include "qs_pkg.hpp"       // QS package-scope internal interface
#include "qp_pkg.hpp"       // QP package-scope interface
#include "qsafe.h"          // QP Functional Safety (FuSa) Subsystem

//============================================================================
//! @cond INTERNAL

namespace { // unnamed local namespace

Q_DEFINE_THIS_MODULE("qs_rx")

//............................................................................
#if (QS_OBJ_PTR_SIZE == 2U)
    using QSObj = std::uint16_t;
#elif (QS_OBJ_PTR_SIZE == 4U)
    using QSObj = std::uint32_t;
#elif (QS_OBJ_PTR_SIZE == 8U)
    using QSObj = std::uint64_t;
#endif

struct CmdVar {
    std::uint32_t param1;
    std::uint32_t param2;
    std::uint32_t param3;
    std::uint8_t  idx;
    std::uint8_t  cmdId;
};

struct TickVar {
    std::uint_fast8_t rate;
};

struct PeekVar {
    std::uint16_t offs;
    std::uint8_t  size;
    std::uint8_t  num;
    std::uint8_t  idx;
};

struct PokeVar {
    std::uint32_t data;
    std::uint16_t offs;
    std::uint8_t  size;
    std::uint8_t  num;
    std::uint8_t  idx;
    std::uint8_t  fill;
};

struct FltVar {
    std::uint8_t data[16];
    std::uint8_t idx;
    std::uint8_t recId; // global/local
};

struct ObjVar {
    QSObj   addr;
    std::uint8_t idx;
    std::uint8_t kind; // see qs.hpp, enum QSpyObjKind
    std::uint8_t recId;
};

struct EvtVar {
    QP::QEvt     *e;
    std::uint8_t *p;
    QP::QSignal   sig;
    std::uint16_t len;
    std::uint8_t  prio;
    std::uint8_t  idx;
};

// extended-state variables for the current QS-RX state
static struct ExtState {
    union Variant {
        CmdVar   cmd;
        TickVar  tick;
        PeekVar  peek;
        PokeVar  poke;
        FltVar   flt;
        ObjVar   obj;
        EvtVar   evt;
#ifdef Q_UTEST
        QP::QS::TProbe tp;
#endif // Q_UTEST
    } var;
    std::uint8_t state;
    std::uint8_t esc;
    std::uint8_t seq;
    std::uint8_t chksum;
} l_rx;

enum RxStateEnum : std::uint8_t {
    ERROR_STATE,
    WAIT4_SEQ,
    WAIT4_REC,
    WAIT4_INFO_FRAME,
    WAIT4_CMD_ID,
    WAIT4_CMD_PARAM1,
    WAIT4_CMD_PARAM2,
    WAIT4_CMD_PARAM3,
    WAIT4_CMD_FRAME,
    WAIT4_RESET_FRAME,
    WAIT4_TICK_RATE,
    WAIT4_TICK_FRAME,
    WAIT4_PEEK_OFFS,
    WAIT4_PEEK_SIZE,
    WAIT4_PEEK_NUM,
    WAIT4_PEEK_FRAME,
    WAIT4_POKE_OFFS,
    WAIT4_POKE_SIZE,
    WAIT4_POKE_NUM,
    WAIT4_POKE_DATA,
    WAIT4_POKE_FRAME,
    WAIT4_FILL_DATA,
    WAIT4_FILL_FRAME,
    WAIT4_FILTER_LEN,
    WAIT4_FILTER_DATA,
    WAIT4_FILTER_FRAME,
    WAIT4_OBJ_KIND,
    WAIT4_OBJ_ADDR,
    WAIT4_OBJ_FRAME,
    WAIT4_QUERY_KIND,
    WAIT4_QUERY_FRAME,
    WAIT4_EVT_PRIO,
    WAIT4_EVT_SIG,
    WAIT4_EVT_LEN,
    WAIT4_EVT_PAR,
    WAIT4_EVT_FRAME

#ifdef Q_UTEST
    ,
    WAIT4_TEST_SETUP_FRAME,
    WAIT4_TEST_TEARDOWN_FRAME,
    WAIT4_TEST_PROBE_DATA,
    WAIT4_TEST_PROBE_ADDR,
    WAIT4_TEST_PROBE_FRAME,
    WAIT4_TEST_CONTINUE_FRAME
#endif // Q_UTEST
};

// internal helper functions...
static void rxParseData_(std::uint8_t const b) noexcept;
static void rxHandleGoodFrame_(std::uint8_t const state);
static void rxHandleBadFrame_(std::uint8_t const state) noexcept;
static void rxReportAck_(enum QP::QSpyRxRecords const recId) noexcept;
static void rxReportError_(std::uint8_t const code) noexcept;
static void rxReportDone_(enum QP::QSpyRxRecords const recId) noexcept;
static void queryCurrObj_(std::uint8_t obj_kind) noexcept;
static void rxPoke_() noexcept;

// Internal QS-RX function to take a tran. in the QS-RX FSM
static inline void tran_(RxStateEnum const target) noexcept {
    l_rx.state = static_cast<std::uint8_t>(target);
}

} // unnamed namespace

namespace QP {
namespace QS {
RxAttr rxPriv_;
} // namespace QS
} // namespace QP

//! @endcond
//============================================================================

//$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
// Check for the minimum required QP version
#if (QP_VERSION < 730U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpcpp version 7.3.0 or higher required
#endif
//$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//$define${QS::QS-RX} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv
namespace QP {
namespace QS {

//${QS::QS-RX::rxInitBuf} ....................................................
void rxInitBuf(
    std::uint8_t * const sto,
    std::uint16_t const stoSize) noexcept
{
    rxPriv_.buf  = &sto[0];
    rxPriv_.end  = static_cast<QSCtr>(stoSize);
    rxPriv_.head = 0U;
    rxPriv_.tail = 0U;

    rxPriv_.currObj[QS::SM_OBJ] = nullptr;
    rxPriv_.currObj[QS::AO_OBJ] = nullptr;
    rxPriv_.currObj[QS::MP_OBJ] = nullptr;
    rxPriv_.currObj[QS::EQ_OBJ] = nullptr;
    rxPriv_.currObj[QS::TE_OBJ] = nullptr;
    rxPriv_.currObj[QS::AP_OBJ] = nullptr;

    tran_(WAIT4_SEQ);
    l_rx.esc    = 0U;
    l_rx.seq    = 0U;
    l_rx.chksum = 0U;

    beginRec_(static_cast<std::uint_fast8_t>(QS_OBJ_DICT));
        QS_OBJ_PRE_(&rxPriv_);
        QS_STR_PRE_("QS_RX");
    endRec_();
    // no QS_REC_DONE(), because QS is not running yet

    #ifdef Q_UTEST
    tstPriv_.tpNum    = 0U;
    tstPriv_.testTime = 0U;
    #endif // Q_UTEST
}

//${QS::QS-RX::rxParse} ......................................................
void rxParse() {
    // NOTE: Must be called IN critical section.
    // Also requires system-level memory access (QF_MEM_SYS()).

    QSCtr tail = rxPriv_.tail;
    while (rxPriv_.head != tail) { // QS-RX buffer NOT empty?
        std::uint8_t b = rxPriv_.buf[tail];

        ++tail;
        if (tail == rxPriv_.end) {
            tail = 0U;
        }
        rxPriv_.tail = tail; // update the tail to a *valid* index

        if (l_rx.esc != 0U) {  // escaped byte arrived?
            l_rx.esc = 0U;
            b ^= QS_ESC_XOR;

            l_rx.chksum += b;
            rxParseData_(b);
        }
        else if (b == QS_ESC) {
            l_rx.esc = 1U;
        }
        else if (b == QS_FRAME) {
            // get ready for the next frame
            b = l_rx.state; // save the current state in b
            l_rx.esc = 0U;
            tran_(WAIT4_SEQ);

            if (l_rx.chksum == QS_GOOD_CHKSUM) {
                l_rx.chksum = 0U;
                rxHandleGoodFrame_(b);
            }
            else { // bad checksum
                l_rx.chksum = 0U;
                rxReportError_(0x41U);
                rxHandleBadFrame_(b);
            }
        }
        else {
            l_rx.chksum += b;
            rxParseData_(b);
        }
    }
}

//${QS::QS-RX::rxGetNfree} ...................................................
std::uint16_t rxGetNfree() noexcept {
    // NOTE: Must be called IN critical section.
    // Also requires system-level memory access (QF_MEM_SYS()).

    QSCtr const head = rxPriv_.head;
    std::uint16_t nFree;
    if (head == rxPriv_.tail) { // buffer empty?
        nFree = static_cast<std::uint16_t>(rxPriv_.end - 1U);
    }
    else if (head < rxPriv_.tail) {
        nFree = static_cast<std::uint16_t>(rxPriv_.tail - head - 1U);
    }
    else {
        nFree = static_cast<std::uint16_t>(rxPriv_.end + rxPriv_.tail
                                          - head - 1U);
    }
    return nFree;
}

} // namespace QS
} // namespace QP
//$enddef${QS::QS-RX} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

//============================================================================
//! @cond INTERNAL
namespace { // unnamed local namespace

//............................................................................
static void rxParseData_(std::uint8_t const b) noexcept {
    switch (l_rx.state) {
        case WAIT4_SEQ: {
            ++l_rx.seq;
            if (l_rx.seq != b) { // not the expected sequence?
                rxReportError_(0x42U);
                l_rx.seq = b; // update the sequence
            }
            tran_(WAIT4_REC);
            break;
        }
        case WAIT4_REC: {
            switch (b) {
                case QP::QS_RX_INFO:
                    tran_(WAIT4_INFO_FRAME);
                    break;
                case QP::QS_RX_COMMAND:
                    tran_(WAIT4_CMD_ID);
                    break;
                case QP::QS_RX_RESET:
                    tran_(WAIT4_RESET_FRAME);
                    break;
                case QP::QS_RX_TICK:
                    tran_(WAIT4_TICK_RATE);
                    break;
                case QP::QS_RX_PEEK:
                    if (QP::QS::rxPriv_.currObj[QP::QS::AP_OBJ] != nullptr) {
                        l_rx.var.peek.offs = 0U;
                        l_rx.var.peek.idx  = 0U;
                        tran_(WAIT4_PEEK_OFFS);
                    }
                    else {
                        rxReportError_(
                            static_cast<std::uint8_t>(QP::QS_RX_PEEK));
                        tran_(ERROR_STATE);
                    }
                    break;
                case QP::QS_RX_POKE:
                case QP::QS_RX_FILL:
                    l_rx.var.poke.fill =
                        (b == static_cast<std::uint8_t>(QP::QS_RX_FILL))
                            ? 1U
                            : 0U;
                    if (QP::QS::rxPriv_.currObj[QP::QS::AP_OBJ] != nullptr) {
                        l_rx.var.poke.offs = 0U;
                        l_rx.var.poke.idx  = 0U;
                        tran_(WAIT4_POKE_OFFS);
                    }
                    else {
                        rxReportError_(
                            (l_rx.var.poke.fill != 0U)
                                ? static_cast<std::uint8_t>(QP::QS_RX_FILL)
                                : static_cast<std::uint8_t>(QP::QS_RX_POKE));
                        tran_(ERROR_STATE);
                    }
                    break;
                case QP::QS_RX_GLB_FILTER: // intentionally fall-through
                case QP::QS_RX_LOC_FILTER:
                    l_rx.var.flt.recId = b;
                    tran_(WAIT4_FILTER_LEN);
                    break;
                case QP::QS_RX_AO_FILTER: // intentionally fall-through
                case QP::QS_RX_CURR_OBJ:
                    l_rx.var.obj.recId = b;
                    tran_(WAIT4_OBJ_KIND);
                    break;
                case QP::QS_RX_QUERY_CURR:
                    l_rx.var.obj.recId =
                        static_cast<std::uint8_t>(QP::QS_RX_QUERY_CURR);
                    tran_(WAIT4_QUERY_KIND);
                    break;
                case QP::QS_RX_EVENT:
                    tran_(WAIT4_EVT_PRIO);
                    break;

#ifdef Q_UTEST
                case QP::QS_RX_TEST_SETUP:
                    tran_(WAIT4_TEST_SETUP_FRAME);
                    break;
                case QP::QS_RX_TEST_TEARDOWN:
                    tran_(WAIT4_TEST_TEARDOWN_FRAME);
                    break;
                case QP::QS_RX_TEST_CONTINUE:
                    tran_(WAIT4_TEST_CONTINUE_FRAME);
                    break;
                case QP::QS_RX_TEST_PROBE:
                    if (QP::QS::tstPriv_.tpNum
                        < static_cast<std::uint8_t>(
                              (sizeof(QP::QS::tstPriv_.tpBuf)
                               / sizeof(QP::QS::tstPriv_.tpBuf[0]))))
                    {
                        l_rx.var.tp.data = 0U;
                        l_rx.var.tp.idx  = 0U;
                        tran_(WAIT4_TEST_PROBE_DATA);
                    }
                    else { // the # Test-Probes exceeded
                        rxReportError_(
                            static_cast<std::uint8_t>(QP::QS_RX_TEST_PROBE));
                        tran_(ERROR_STATE);
                    }
                    break;
#endif // Q_UTEST

                default:
                    rxReportError_(0x43U);
                    tran_(ERROR_STATE);
                    break;
            }
            break;
        }
        case WAIT4_INFO_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_CMD_ID: {
            l_rx.var.cmd.cmdId  = b;
            l_rx.var.cmd.idx    = 0U;
            l_rx.var.cmd.param1 = 0U;
            l_rx.var.cmd.param2 = 0U;
            l_rx.var.cmd.param3 = 0U;
            tran_(WAIT4_CMD_PARAM1);
            break;
        }
        case WAIT4_CMD_PARAM1: {
            l_rx.var.cmd.param1 |=
                (static_cast<std::uint32_t>(b) << l_rx.var.cmd.idx);
            l_rx.var.cmd.idx    += 8U;
            if (l_rx.var.cmd.idx == (8U*4U)) {
                l_rx.var.cmd.idx = 0U;
                tran_(WAIT4_CMD_PARAM2);
            }
            break;
        }
        case WAIT4_CMD_PARAM2: {
            l_rx.var.cmd.param2 |=
                static_cast<std::uint32_t>(b) << l_rx.var.cmd.idx;
            l_rx.var.cmd.idx    += 8U;
            if (l_rx.var.cmd.idx == (8U*4U)) {
                l_rx.var.cmd.idx = 0U;
                tran_(WAIT4_CMD_PARAM3);
            }
            break;
        }
        case WAIT4_CMD_PARAM3: {
            l_rx.var.cmd.param3 |=
                static_cast<std::uint32_t>(b) << l_rx.var.cmd.idx;
            l_rx.var.cmd.idx    += 8U;
            if (l_rx.var.cmd.idx == (8U*4U)) {
                l_rx.var.cmd.idx = 0U;
                tran_(WAIT4_CMD_FRAME);
            }
            break;
        }
        case WAIT4_CMD_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_RESET_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_TICK_RATE: {
            l_rx.var.tick.rate = static_cast<std::uint_fast8_t>(b);
            tran_(WAIT4_TICK_FRAME);
            break;
        }
        case WAIT4_TICK_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_PEEK_OFFS: {
            if (l_rx.var.peek.idx == 0U) {
                l_rx.var.peek.offs = static_cast<std::uint16_t>(b);
                l_rx.var.peek.idx += 8U;
            }
            else {
                l_rx.var.peek.offs |= static_cast<std::uint16_t>(
                                         static_cast<std::uint16_t>(b) << 8U);
                tran_(WAIT4_PEEK_SIZE);
            }
            break;
        }
        case WAIT4_PEEK_SIZE: {
            if ((b == 1U) || (b == 2U) || (b == 4U)) {
                l_rx.var.peek.size = b;
                tran_(WAIT4_PEEK_NUM);
            }
            else {
                rxReportError_(static_cast<std::uint8_t>(QP::QS_RX_PEEK));
                tran_(ERROR_STATE);
            }
            break;
        }
        case WAIT4_PEEK_NUM: {
            l_rx.var.peek.num = b;
            tran_(WAIT4_PEEK_FRAME);
            break;
        }
        case WAIT4_PEEK_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_POKE_OFFS: {
            if (l_rx.var.poke.idx == 0U) {
                l_rx.var.poke.offs = static_cast<std::uint16_t>(b);
                l_rx.var.poke.idx  = 1U;
            }
            else {
                l_rx.var.poke.offs |= static_cast<std::uint16_t>(
                                         static_cast<std::uint16_t>(b) << 8U);
                tran_(WAIT4_POKE_SIZE);
            }
            break;
        }
        case WAIT4_POKE_SIZE: {
            if ((b == 1U) || (b == 2U) || (b == 4U)) {
                l_rx.var.poke.size = b;
                tran_(WAIT4_POKE_NUM);
            }
            else {
                rxReportError_((l_rx.var.poke.fill != 0U)
                                  ? static_cast<std::uint8_t>(QP::QS_RX_FILL)
                                  : static_cast<std::uint8_t>(QP::QS_RX_POKE));
                tran_(ERROR_STATE);
            }
            break;
        }
        case WAIT4_POKE_NUM: {
            if (b > 0U) {
                l_rx.var.poke.num  = b;
                l_rx.var.poke.data = 0U;
                l_rx.var.poke.idx  = 0U;
                tran_((l_rx.var.poke.fill != 0U)
                            ? WAIT4_FILL_DATA
                            : WAIT4_POKE_DATA);
            }
            else {
                rxReportError_((l_rx.var.poke.fill != 0U)
                                  ? static_cast<std::uint8_t>(QP::QS_RX_FILL)
                                  : static_cast<std::uint8_t>(QP::QS_RX_POKE));
                tran_(ERROR_STATE);
            }
            break;
        }
        case WAIT4_FILL_DATA: {
            l_rx.var.poke.data |=
                static_cast<std::uint32_t>(b) << l_rx.var.poke.idx;
            l_rx.var.poke.idx += 8U;
            if ((l_rx.var.poke.idx >> 3U) == l_rx.var.poke.size) {
                tran_(WAIT4_FILL_FRAME);
            }
            break;
        }
        case WAIT4_POKE_DATA: {
            l_rx.var.poke.data |=
                static_cast<std::uint32_t>(b) << l_rx.var.poke.idx;
            l_rx.var.poke.idx += 8U;
            if ((l_rx.var.poke.idx >> 3U) == l_rx.var.poke.size) {
                rxPoke_();
                --l_rx.var.poke.num;
                if (l_rx.var.poke.num == 0U) {
                    tran_(WAIT4_POKE_FRAME);
                }
            }
            break;
        }
        case WAIT4_FILL_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_POKE_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_FILTER_LEN: {
            if (b == static_cast<std::uint8_t>(sizeof(l_rx.var.flt.data))) {
                l_rx.var.flt.idx = 0U;
                tran_(WAIT4_FILTER_DATA);
            }
            else {
                rxReportError_(l_rx.var.flt.recId);
                tran_(ERROR_STATE);
            }
            break;
        }
        case WAIT4_FILTER_DATA: {
            l_rx.var.flt.data[l_rx.var.flt.idx] = b;
            ++l_rx.var.flt.idx;
            if (l_rx.var.flt.idx == sizeof(l_rx.var.flt.data)) {
                tran_(WAIT4_FILTER_FRAME);
            }
            break;
        }
        case WAIT4_FILTER_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_OBJ_KIND: {
            if (b <= static_cast<std::uint8_t>(QP::QS::SM_AO_OBJ)) {
                l_rx.var.obj.kind = b;
                l_rx.var.obj.addr = 0U;
                l_rx.var.obj.idx  = 0U;
                tran_(WAIT4_OBJ_ADDR);
            }
            else {
                rxReportError_(l_rx.var.obj.recId);
                tran_(ERROR_STATE);
            }
            break;
        }
        case WAIT4_OBJ_ADDR: {
            l_rx.var.obj.addr |=
                static_cast<QSObj>(b) << l_rx.var.obj.idx;
            l_rx.var.obj.idx += 8U;
            if (l_rx.var.obj.idx
                == (8U * static_cast<unsigned>(QS_OBJ_PTR_SIZE)))
            {
                tran_(WAIT4_OBJ_FRAME);
            }
            break;
        }
        case WAIT4_OBJ_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_QUERY_KIND: {
            if (b < static_cast<std::uint8_t>(QP::QS::MAX_OBJ)) {
                l_rx.var.obj.kind = b;
                tran_(WAIT4_QUERY_FRAME);
            }
            else {
                rxReportError_(l_rx.var.obj.recId);
                tran_(ERROR_STATE);
            }
            break;
        }
        case WAIT4_QUERY_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_EVT_PRIO: {
            l_rx.var.evt.prio = b;
            l_rx.var.evt.sig  = 0U;
            l_rx.var.evt.idx  = 0U;
            tran_(WAIT4_EVT_SIG);
            break;
        }
        case WAIT4_EVT_SIG: {
            l_rx.var.evt.sig |= static_cast<QP::QSignal>(
                          static_cast<std::uint32_t>(b) << l_rx.var.evt.idx);
            l_rx.var.evt.idx += 8U;
            if (l_rx.var.evt.idx
                == (8U *static_cast<unsigned>(Q_SIGNAL_SIZE)))
            {
                l_rx.var.evt.len = 0U;
                l_rx.var.evt.idx = 0U;
                tran_(WAIT4_EVT_LEN);
            }
            break;
        }
        case WAIT4_EVT_LEN: {
            l_rx.var.evt.len |= static_cast<std::uint16_t>(
                                static_cast<unsigned>(b) << l_rx.var.evt.idx);
            l_rx.var.evt.idx += 8U;
            if (l_rx.var.evt.idx == (8U * 2U)) {
                if ((l_rx.var.evt.len + sizeof(QP::QEvt))
                    <= static_cast<std::uint16_t>(
                                   QP::QF::poolGetMaxBlockSize()))
                {
                    // report Ack before generating any other QS records
                    rxReportAck_(QP::QS_RX_EVENT);

                    l_rx.var.evt.e = QP::QF::newX_(
                        (static_cast<std::uint_fast16_t>(l_rx.var.evt.len)
                         + sizeof(QP::QEvt)),
                        0U, // margin
                        static_cast<enum_t>(l_rx.var.evt.sig));
                    // event allocated?
                    if (l_rx.var.evt.e != nullptr) {
                        l_rx.var.evt.p =
                            reinterpret_cast<std::uint8_t *>(l_rx.var.evt.e);
                        l_rx.var.evt.p = &l_rx.var.evt.p[sizeof(QP::QEvt)];
                        if (l_rx.var.evt.len > 0U) {
                            tran_(WAIT4_EVT_PAR);
                        }
                        else {
                            tran_(WAIT4_EVT_FRAME);
                        }
                    }
                    else {
                        rxReportError_(
                            static_cast<std::uint8_t>(QP::QS_RX_EVENT));
                        tran_(ERROR_STATE);
                    }
                }
                else {
                    rxReportError_(
                        static_cast<std::uint8_t>(QP::QS_RX_EVENT));
                    tran_(ERROR_STATE);
                }
            }
            break;
        }
        case WAIT4_EVT_PAR: { // event parameters
            *l_rx.var.evt.p = b;
            ++l_rx.var.evt.p;
            --l_rx.var.evt.len;
            if (l_rx.var.evt.len == 0U) {
                tran_(WAIT4_EVT_FRAME);
            }
            break;
        }
        case WAIT4_EVT_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }

#ifdef Q_UTEST
        case WAIT4_TEST_SETUP_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_TEST_TEARDOWN_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_TEST_CONTINUE_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
        case WAIT4_TEST_PROBE_DATA: {
            l_rx.var.tp.data |=
                (static_cast<QP::QSFun>(b) << l_rx.var.tp.idx);
            l_rx.var.tp.idx += 8U;
            if (l_rx.var.tp.idx == (8U * sizeof(std::uint32_t))) {
                l_rx.var.tp.addr = 0U;
                l_rx.var.tp.idx  = 0U;
                tran_(WAIT4_TEST_PROBE_ADDR);
            }
            break;
        }
        case WAIT4_TEST_PROBE_ADDR: {
            l_rx.var.tp.addr |=
                (static_cast<std::uint32_t>(b) << l_rx.var.tp.idx);
            l_rx.var.tp.idx += 8U;
            if (l_rx.var.tp.idx
                == (8U * static_cast<unsigned>(QS_FUN_PTR_SIZE)))
            {
                tran_(WAIT4_TEST_PROBE_FRAME);
            }
            break;
        }
        case WAIT4_TEST_PROBE_FRAME: {
            // keep ignoring the data until a frame is collected
            break;
        }
#endif // Q_UTEST

        case ERROR_STATE: {
            // keep ignoring the data until a good frame is collected
            break;
        }
        default: { // unexpected or unimplemented state
            rxReportError_(0x45U);
            tran_(ERROR_STATE);
            break;
        }
    }
}

//............................................................................
void rxHandleGoodFrame_(std::uint8_t const state) {
    std::uint8_t i;
    std::uint8_t *ptr;

    switch (state) {
        case WAIT4_INFO_FRAME: {
            // no need to report Ack or Done
            QP::QS::target_info_pre_(0U); // send only Target info
            break;
        }
        case WAIT4_RESET_FRAME: {
            // no need to report Ack or Done, because Target resets
            QP::QS::onReset(); // reset the Target
            break;
        }
        case WAIT4_CMD_PARAM1: // intentionally fall-through
        case WAIT4_CMD_PARAM2: // intentionally fall-through
        case WAIT4_CMD_PARAM3: // intentionally fall-through
        case WAIT4_CMD_FRAME: {
            rxReportAck_(QP::QS_RX_COMMAND);
            QP::QS::onCommand(l_rx.var.cmd.cmdId, l_rx.var.cmd.param1,
                          l_rx.var.cmd.param2, l_rx.var.cmd.param3);
#ifdef Q_UTEST
    #if Q_UTEST != 0
            QP::QS::processTestEvts_(); // process all events produced
    #endif  // Q_UTEST != 0
#endif  // Q_UTEST
            rxReportDone_(QP::QS_RX_COMMAND);
            break;
        }
        case WAIT4_TICK_FRAME: {
            rxReportAck_(QP::QS_RX_TICK);
#ifdef Q_UTEST
            QP::QTimeEvt::tick1_(
                static_cast<std::uint_fast8_t>(l_rx.var.tick.rate),
                &QP::QS::rxPriv_);
    #if Q_UTEST != 0
            QP::QS::processTestEvts_(); // process all events produced
    #endif  // Q_UTEST != 0
#else
            QP::QTimeEvt::tick(
                static_cast<std::uint_fast8_t>(l_rx.var.tick.rate),
                &QP::QS::rxPriv_);
#endif  // Q_UTEST
            rxReportDone_(QP::QS_RX_TICK);
            break;
        }
        case WAIT4_PEEK_FRAME: {
            // no need to report Ack or Done
            QP::QS::beginRec_(static_cast<std::uint_fast8_t>(
                                 QP::QS_PEEK_DATA));
                ptr = static_cast<std::uint8_t*>(
                          QP::QS::rxPriv_.currObj[QP::QS::AP_OBJ]);
                ptr = &ptr[l_rx.var.peek.offs];
                QS_TIME_PRE_();                  // timestamp
                QS_U16_PRE_(l_rx.var.peek.offs); // data offset
                QS_U8_PRE_(l_rx.var.peek.size);  // data size
                QS_U8_PRE_(l_rx.var.peek.num);   // number of data items
                for (i = 0U; i < l_rx.var.peek.num; ++i) {
                    switch (l_rx.var.peek.size) {
                        case 1:
                            QS_U8_PRE_(ptr[i]);
                            break;
                        case 2:
                            QS_U16_PRE_(
                                reinterpret_cast<std::uint16_t*>(ptr)[i]);
                            break;
                        case 4:
                            QS_U32_PRE_(
                                reinterpret_cast<std::uint32_t*>(ptr)[i]);
                            break;
                        default:
                            // intentionally empty
                            break;
                    }
                }
            QP::QS::endRec_();

            QS_REC_DONE(); // user callback (if defined)
            break;
        }
        case WAIT4_POKE_DATA: {
            // received less than expected poke data items
            rxReportError_(static_cast<std::uint8_t>(QP::QS_RX_POKE));
            break;
        }
        case WAIT4_POKE_FRAME: {
            rxReportAck_(QP::QS_RX_POKE);
            // no need to report done
            break;
        }
        case WAIT4_FILL_FRAME: {
            rxReportAck_(QP::QS_RX_FILL);
            ptr = static_cast<std::uint8_t *>(
                      QP::QS::rxPriv_.currObj[QP::QS::AP_OBJ]);
            ptr = &ptr[l_rx.var.poke.offs];
            for (i = 0U; i < l_rx.var.poke.num; ++i) {
                switch (l_rx.var.poke.size) {
                    case 1:
                        ptr[i] =
                            static_cast<std::uint8_t>(l_rx.var.poke.data);
                        break;
                    case 2:
                        reinterpret_cast<std::uint16_t *>(ptr)[i] =
                            static_cast<std::uint16_t>(l_rx.var.poke.data);
                        break;
                    case 4:
                        reinterpret_cast<std::uint32_t *>(ptr)[i] =
                            l_rx.var.poke.data;
                        break;
                    default:
                        // intentionally empty
                        break;
                }
            }
            break;
        }
        case WAIT4_FILTER_FRAME: {
            rxReportAck_(static_cast<enum QP::QSpyRxRecords>(
                             l_rx.var.flt.recId));

            // apply the received filters
            if (l_rx.var.flt.recId
                == static_cast<std::uint8_t>(QP::QS_RX_GLB_FILTER))
            {
                for (i = 0U;
                     i < static_cast<std::uint8_t>(sizeof(QP::QS::filt_.glb));
                     ++i)
                {
                    QP::QS::filt_.glb[i] = l_rx.var.flt.data[i];
                }
                // leave the "not maskable" filters enabled,
                // see qs.hpp, Miscellaneous QS records (not maskable)
                QP::QS::filt_.glb[0] |= 0x01U;
                QP::QS::filt_.glb[7] |= 0xFCU;
                QP::QS::filt_.glb[8] |= 0x7FU;

                // never enable the last 3 records (0x7D, 0x7E, 0x7F)
                QP::QS::filt_.glb[15] &= 0x1FU;
            }
            else if (l_rx.var.flt.recId
                     == static_cast<std::uint8_t>(QP::QS_RX_LOC_FILTER))
            {
                for (i = 0U; i < Q_DIM(QP::QS::filt_.loc); ++i) {
                    QP::QS::filt_.loc[i] = l_rx.var.flt.data[i];
                }
                // leave QS_ID == 0 always on
                QP::QS::filt_.loc[0] |= 0x01U;
            }
            else {
                rxReportError_(l_rx.var.flt.recId);
            }
            // no need to report Done
            break;
        }
        case WAIT4_OBJ_FRAME: {
            i = l_rx.var.obj.kind;
            if (i < static_cast<std::uint8_t>(QP::QS::MAX_OBJ)) {
                if (l_rx.var.obj.recId
                    == static_cast<std::uint8_t>(QP::QS_RX_CURR_OBJ))
                {
                    QP::QS::rxPriv_.currObj[i] =
                        reinterpret_cast<void *>(l_rx.var.obj.addr);
                    rxReportAck_(QP::QS_RX_CURR_OBJ);
                }
                else if (l_rx.var.obj.recId
                         == static_cast<std::uint8_t>(QP::QS_RX_AO_FILTER))
                {
                    if (l_rx.var.obj.addr != 0U) {
                        std::int_fast16_t const filter =
                            static_cast<std::int_fast16_t>(
                                reinterpret_cast<QP::QActive *>(
                                    l_rx.var.obj.addr)->getPrio());
                        QP::QS::locFilter_((i == 0)
                                           ? filter
                                           :-filter);
                        rxReportAck_(QP::QS_RX_AO_FILTER);
                    }
                    else {
                        rxReportError_(static_cast<enum_t>(
                                           QP::QS_RX_AO_FILTER));
                    }
                }
                else {
                    rxReportError_(l_rx.var.obj.recId);
                }
            }
            // both SM and AO
            else if (i == static_cast<std::uint8_t>(QP::QS::SM_AO_OBJ)) {
                if (l_rx.var.obj.recId
                    == static_cast<std::uint8_t>(QP::QS_RX_CURR_OBJ))
                {
                    QP::QS::rxPriv_.currObj[QP::QS::SM_OBJ]
                        = reinterpret_cast<void *>(l_rx.var.obj.addr);
                    QP::QS::rxPriv_.currObj[QP::QS::AO_OBJ]
                        = reinterpret_cast<void *>(l_rx.var.obj.addr);
                }
                rxReportAck_(
                    static_cast<enum QP::QSpyRxRecords>(l_rx.var.obj.recId));
            }
            else {
                rxReportError_(l_rx.var.obj.recId);
            }
            break;
        }
        case WAIT4_QUERY_FRAME: {
            queryCurrObj_(l_rx.var.obj.kind);
            break;
        }
        case WAIT4_EVT_FRAME: {
            // NOTE: Ack was already reported in the WAIT4_EVT_LEN state
#ifdef Q_UTEST
            QP::QS::onTestEvt(l_rx.var.evt.e); // "massage" the event
#endif  // Q_UTEST
            // use 'i' as status, 0 == success,no-recycle
            i = 0U;

            if (l_rx.var.evt.prio == 0U) { // publish
                QP::QActive::publish_(l_rx.var.evt.e, &QP::QS::rxPriv_, 0U);
            }
            else if (l_rx.var.evt.prio < QF_MAX_ACTIVE) {
                if (!QP::QActive::registry_[l_rx.var.evt.prio]->POST_X(
                                l_rx.var.evt.e,
                                0U, // margin
                                &QP::QS::rxPriv_))
                {
                    // failed QACTIVE_POST() recycles the event
                    i = 0x80U; // failure, no recycle
                }
            }
            else if (l_rx.var.evt.prio == 255U) {
                // dispatch to the current SM object
                if (QP::QS::rxPriv_.currObj[QP::QS::SM_OBJ] != nullptr) {
                    // increment the ref-ctr to simulate the situation
                    // when the event is just retreived from a queue.
                    // This is expected for the following QF::gc() call.
                    QP::QEvt_refCtr_inc_(l_rx.var.evt.e);

                    static_cast<QP::QAsm *>(
                        QP::QS::rxPriv_.currObj[QP::QS::SM_OBJ])
                            ->dispatch(l_rx.var.evt.e, 0U);
                    i = 0x01U;  // success, recycle
                }
                else {
                    i = 0x81U;  // failure, recycle
                }
            }
            else if (l_rx.var.evt.prio == 254U) {
                // init the current SM object"
                if (QP::QS::rxPriv_.currObj[QP::QS::SM_OBJ] != nullptr) {
                    // increment the ref-ctr to simulate the situation
                    // when the event is just retreived from a queue.
                    // This is expected for the following QF::gc() call.
                    QP::QEvt_refCtr_inc_(l_rx.var.evt.e);

                    static_cast<QP::QAsm *>(
                        QP::QS::rxPriv_.currObj[QP::QS::SM_OBJ])
                            ->init(l_rx.var.evt.e, 0U);
                    i = 0x01U;  // success, recycle
                }
                else {
                    i = 0x81U;  // failure, recycle
                }
            }
            else if (l_rx.var.evt.prio == 253U) {
                // post to the current AO
                if (QP::QS::rxPriv_.currObj[QP::QS::AO_OBJ] != nullptr) {
                    if (!static_cast<QP::QActive *>(
                            QP::QS::rxPriv_.currObj[QP::QS::AO_OBJ])->POST_X(
                                l_rx.var.evt.e,
                                0U, // margin
                                &QP::QS::rxPriv_))
                    {
                        // failed QACTIVE_POST() recycles the event
                        i = 0x80U; // failure, no recycle
                    }
                }
                else {
                    i = 0x81U;  // failure, recycle
                }
            }
            else {
                i = 0x81U;  // failure, recycle
            }

#if (QF_MAX_EPOOL > 0U)
            // recycle needed?
            if ((i & 1U) != 0U) {
                QP::QF::gc(l_rx.var.evt.e);
            }
#endif
            // failure?
            if ((i & 0x80U) != 0U) {
                rxReportError_(static_cast<std::uint8_t>(QP::QS_RX_EVENT));
            }
            else {
#ifdef Q_UTEST
    #if Q_UTEST != 0
                QP::QS::processTestEvts_(); // process all events produced
    #endif  // Q_UTEST != 0
#endif  // Q_UTEST
                rxReportDone_(QP::QS_RX_EVENT);
            }
            break;
        }

#ifdef Q_UTEST
        case WAIT4_TEST_SETUP_FRAME: {
            rxReportAck_(QP::QS_RX_TEST_SETUP);
            QP::QS::tstPriv_.tpNum = 0U; // clear Test-Probes
            QP::QS::tstPriv_.testTime = 0U; //clear time tick
            // don't clear current objects
            QP::QS::onTestSetup(); // application-specific test setup
            // no need to report Done
            break;
        }
        case WAIT4_TEST_TEARDOWN_FRAME: {
            rxReportAck_(QP::QS_RX_TEST_TEARDOWN);
            QP::QS::onTestTeardown(); // application-specific test teardown
            // no need to report Done
            break;
        }
        case WAIT4_TEST_CONTINUE_FRAME: {
            rxReportAck_(QP::QS_RX_TEST_CONTINUE);
            QP::QS::rxPriv_.inTestLoop = false; // exit the QUTest loop
            // no need to report Done
            break;
        }
        case WAIT4_TEST_PROBE_FRAME: {
            rxReportAck_(QP::QS_RX_TEST_PROBE);
            Q_ASSERT_INCRIT(815,
                QP::QS::tstPriv_.tpNum
                   < (sizeof(QP::QS::tstPriv_.tpBuf)
                      / sizeof(QP::QS::tstPriv_.tpBuf[0])));
            QP::QS::tstPriv_.tpBuf[QP::QS::tstPriv_.tpNum] = l_rx.var.tp;
            ++QP::QS::tstPriv_.tpNum;
            // no need to report Done
            break;
        }
#endif // Q_UTEST

        case ERROR_STATE: {
            // keep ignoring all bytes until new frame
            break;
        }
        default: {
            rxReportError_(0x47U);
            break;
        }
    }
}

//............................................................................
static void rxHandleBadFrame_(std::uint8_t const state) noexcept {
    rxReportError_(0x50U); // error for all bad frames
    switch (state) {
        case WAIT4_EVT_FRAME: {
            Q_ASSERT_INCRIT(910, l_rx.var.evt.e != nullptr);
#if (QF_MAX_EPOOL > 0U)
            QP::QF::gc(l_rx.var.evt.e); // don't leak an allocated event
#endif
            break;
        }
        default: {
            // intentionally empty
            break;
        }
    }
}

//............................................................................
static void rxReportAck_(enum QP::QSpyRxRecords const recId) noexcept {
    QP::QS::beginRec_(static_cast<std::uint_fast8_t>(QP::QS_RX_STATUS));
        QS_U8_PRE_(recId); // record ID
    QP::QS::endRec_();
    QS_REC_DONE(); // user callback (if defined)
}

//............................................................................
static void rxReportError_(std::uint8_t const code) noexcept {
    QP::QS::beginRec_(static_cast<std::uint_fast8_t>(QP::QS_RX_STATUS));
        QS_U8_PRE_(0x80U | code); // error code
    QP::QS::endRec_();
    QS_REC_DONE(); // user callback (if defined)
}

//............................................................................
static void rxReportDone_(enum QP::QSpyRxRecords const recId) noexcept {
    QP::QS::beginRec_(static_cast<std::uint_fast8_t>(QP::QS_TARGET_DONE));
        QS_TIME_PRE_();    // timestamp
        QS_U8_PRE_(recId); // record ID
    QP::QS::endRec_();
    QS_REC_DONE(); // user callback (if defined)
}

//............................................................................
static void queryCurrObj_(std::uint8_t obj_kind) noexcept {
    Q_REQUIRE_INCRIT(200, obj_kind < Q_DIM(QP::QS::rxPriv_.currObj));

    if (QP::QS::rxPriv_.currObj[obj_kind] != nullptr) {
        QP::QS::beginRec_(static_cast<std::uint_fast8_t>(QP::QS_QUERY_DATA));
            QS_TIME_PRE_(); // timestamp
            QS_U8_PRE_(obj_kind);  // object kind
            QS_OBJ_PRE_(QP::QS::rxPriv_.currObj[obj_kind]); // object pointer
            switch (obj_kind) {
                case QP::QS::SM_OBJ: // intentionally fall through
                case QP::QS::AO_OBJ:
                    QS_FUN_PRE_(reinterpret_cast<QP::QHsm *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->getStateHandler());
                    break;
                case QP::QS::MP_OBJ:
                    QS_MPC_PRE_(reinterpret_cast<QP::QMPool *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->getNFree());
                    QS_MPC_PRE_(reinterpret_cast<QP::QMPool *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->getNMin());
                    break;
                case QP::QS::EQ_OBJ:
                    QS_EQC_PRE_(reinterpret_cast<QP::QEQueue *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->getNFree());
                    QS_EQC_PRE_(reinterpret_cast<QP::QEQueue *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->getNMin());
                    break;
                case QP::QS::TE_OBJ:
                    QS_OBJ_PRE_(reinterpret_cast<QP::QTimeEvt *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->getAct());
                    QS_TEC_PRE_(reinterpret_cast<QP::QTimeEvt *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->getCtr());
                    QS_TEC_PRE_(reinterpret_cast<QP::QTimeEvt *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->getInterval());
                    QS_SIG_PRE_(reinterpret_cast<QP::QTimeEvt *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->sig);
                    QS_U8_PRE_ (reinterpret_cast<QP::QTimeEvt *>(
                        QP::QS::rxPriv_.currObj[obj_kind])->refCtr_);
                    break;
                default:
                    // intentionally empty
                    break;
            }
        QP::QS::endRec_();
        QS_REC_DONE(); // user callback (if defined)
    }
    else {
        rxReportError_(static_cast<std::uint8_t>(QP::QS_RX_AO_FILTER));
    }
}

//............................................................................
static void rxPoke_() noexcept {
    std::uint8_t * ptr =
        static_cast<std::uint8_t *>(QP::QS::rxPriv_.currObj[QP::QS::AP_OBJ]);
    ptr = &ptr[l_rx.var.poke.offs];
    switch (l_rx.var.poke.size) {
        case 1:
            *ptr = static_cast<std::uint8_t>(l_rx.var.poke.data);
            break;
        case 2:
            *reinterpret_cast<std::uint16_t *>(ptr)
                = static_cast<std::uint16_t>(l_rx.var.poke.data);
            break;
        case 4:
            *reinterpret_cast<std::uint32_t *>(ptr) = l_rx.var.poke.data;
            break;
        default:
            Q_ERROR_ID(900);
            break;
    }

    l_rx.var.poke.data = 0U;
    l_rx.var.poke.idx  = 0U;
    l_rx.var.poke.offs += static_cast<std::uint16_t>(l_rx.var.poke.size);
}

} // unnamed namespace

//! @endcond
